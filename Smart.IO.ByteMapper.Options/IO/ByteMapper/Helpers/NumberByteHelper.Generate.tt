// <auto-generated />
<#
    var digitValues = new byte[96][];
    var value = 0m;
    for (var i = 0; i < 96; i++)
    {
        value = value == 0 ? 1m : value * 2;
		var workValue = value;

		var bytes = new byte[29];
        var index = 0;
        while (workValue > 0)
        {
            bytes[index++] = (byte)(workValue % 10);
            workValue = Math.Truncate(workValue / 10);
        }

        digitValues[i] = bytes;
    }

    var workTable = new long[12 * 256 * 2];
    for (var bit = 0; bit < 96; bit++)
    {
        var bitBlock = bit / 8;
        var blockBit = bit % 8;
        var mask = 0b00000001 << blockBit;

        for (var blockValue = 0; blockValue < 256; blockValue++)
        {
            if ((blockValue & mask) != 0)
            {
                for (var digit = 0; digit < 29; digit++)
                {
                    var block = digit / 15;
                    var exponent = digit % 15;

                    var v = (long)digitValues[bit][digit];

                    if (v == 0)
                    {
                        continue;
                    }

                    for (var k = 0; k < exponent; k++)
                    {
                        v *= 10;
                    }

                    while ((v > 0) && (block < 2))
                    {
                        var index = (bitBlock << 9) + (blockValue << 1) + block;
                        var newValue = workTable[index] + v;
                        if (newValue < 1000000000000000L)
                        {
                            workTable[index] = newValue;
                            v = 0;
                        }
                        else
                        {
                            workTable[index] = newValue - 1000000000000000L;
                            v = 1;
                            block++;
                        }
                    }
                }
            }
        }
    }
#>
namespace Smart.IO.ByteMapper.Helpers
{
    internal static partial class NumberByteHelper
    {
        private static readonly long[] Table =
		{
<#
    for (var i = 0; i < workTable.Length; i += 2)
	{
#>
            <#= workTable[i] #>, <#= workTable[i + 1] #>,
<#
	}
#>
        };
    }
}
